"""
Generate an enum and mapping for function-level replacement types.
If no mapping output file or enum output file is specified with the -m or -e
flags, then stdout will be used instead.
"""

import argparse
import os.path
import sys

"""
Take in the name of a file containing a mapping of function names to
replacement type enums, represented by lines of replacement type enums and
comma-separated function names that correspond to those enums, separated by
whitespace.
@param   input_file_name     the name of the file containing the mapping of
                             replacement type enums to function names
@return  A list whose keys are replacement types, and whose values are lists
         of function names that use that replacement type
"""
def read_replacement_type_mapping(input_file_name):
    replacement_type_mapping = {}

    try:
        input_file = open(input_file_name, 'r')
    except FileNotFoundError:
        print('Input file %s not found' % input_file_name)
        raise
    except IOError:
        print('Cannot open %s\n' % input_file_name)
        raise

    for line in input_file:
        # Split a line into the replacement type and a comma-separated string
        # of function names that correspond to that replacement type
        replacement_type, functions_str = line.split(None, 1)

        # split the string of function names into a set
        functions_list = set(func_name.strip()
                             for func_name
                             in functions_str.split(','))

        # add the enum and function names into the mapping list
        replacement_type_mapping[replacement_type] = \
            replacement_type_mapping.get(replacement_type, set()) | functions_list

    return replacement_type_mapping

"""
Main function of the program.  Generates a header file containing an enum for
the different replacement types and a second header file containing a mapping
from function names to the replacement type enum
"""
def main():
    parser = argparse.ArgumentParser(
        description='''Generate an enum for each replacement type and a
                       corresponding replacement type to instrumented function
                       name mapping''')

    parser.add_argument('-m', '--mapping',
                        help='File to store function name to replacement type'
                             ' mapping, defaults to stdout')
    parser.add_argument('-e', '--enum',
                        help='File to store replacement type enum, defaults to'
                             ' stdout')
    parser.add_argument('-i', '--input',
                        help='''File containing a mapping from instrumented
                                functions to replacement types, to be used as
                                input''')

    args = parser.parse_args()

    if args.input:
        replacement_type_mapping = read_replacement_type_mapping(args.input)
    else:
        replacement_type_mapping = {}

    if args.mapping:
        mapping_file = open(args.mapping, 'w')
    else:
        mapping_file = sys.stdout

    if args.enum:
        enum_file = open(args.enum, 'w')
    else:
        enum_file = sys.stdout

    enum_file.write('// Generated by generate_replacement_type_enum.py\n')
    enum_file.write('\n')

    # Add header guards
    enum_file.write('#ifndef %s\n'
        % (os.path.basename(args.enum).rsplit('.', 1)[0].upper() + "_H"))
    enum_file.write('#define %s\n'
        % (os.path.basename(args.enum).rsplit('.', 1)[0].upper() + "_H"))

    enum_file.write('\n')
    enum_file.write('using namespace std;\n')
    enum_file.write('\n')

    enum_file.write('typedef enum {\n')
    enum_file.write('    _no_replacement_type,\n')
    for replacement_type in replacement_type_mapping.keys():
        enum_file.write('    %s,\n' % replacement_type)
    enum_file.write('} _replacement_type;\n')
    enum_file.write('\n')
    enum_file.write('#endif\n')


    mapping_file.write('// Generated by generate_replacement_type_enum.py\n')
    mapping_file.write('\n')

    # Add header guards
    mapping_file.write('#ifndef %s\n'
        % (os.path.basename(args.mapping).rsplit('.', 1)[0].upper() + "_H"))
    mapping_file.write('#define %s\n'
        % (os.path.basename(args.mapping).rsplit('.', 1)[0].upper() + "_H"))

    mapping_file.write('\n')
    mapping_file.write('#include "%s"\n'
        % (os.path.basename(args.enum) if args.enum else "stdout"))
    mapping_file.write('\n')
    mapping_file.write('using namespace std;\n')
    mapping_file.write('\n')

    mapping_file.write('struct func_mapping_entry {\n')
    mapping_file.write('    const char *func_name;\n')
    mapping_file.write('    _replacement_type type;\n')
    mapping_file.write('};\n')
    mapping_file.write('\n')

    mapping_file.write('static struct func_mapping_entry func_mapping_table[]'
                      ' = {\n')
    for mapping_entry in replacement_type_mapping.items():
        replacement_type = mapping_entry[0]

        for func_name in mapping_entry[1]:
            mapping_file.write('    {"%s", %s},\n'
                               % (func_name, replacement_type))
    mapping_file.write('    {NULL, _no_replacement_type}\n')
    mapping_file.write('};\n')
    mapping_file.write('\n')
    mapping_file.write('#endif\n')

    try:
        enum_file.close()
    except IOError:
        pass

    try:
        mapping_file.close()
    except IOError:
        pass


if __name__ == '__main__':
    main()
