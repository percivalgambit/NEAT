import argparse
import os.path
import sys

def read_replacement_type_mapping(input_file_name):
    replacement_type_mapping = {}

    try:
        input_file = open(input_file_name, 'r')
    except FileNotFoundError:
        print('Input file %s not found' % input_file_name)
        raise
    except IOError:
        print('Cannot open %s\n' % input_file_name)
        raise

    for line in input_file:
        replacement_type, functions_str = line.split(maxsplit=1)
        functions_list = [func_name.strip()
                          for func_name
                          in functions_str.split(',')]

        replacement_type_mapping[replacement_type] = functions_list

    return replacement_type_mapping

def main():
    parser = argparse.ArgumentParser(
        description='''Generate an enum for each replacement type and a
                       corresponding replacement type to instrumented function
                       name mapping''')

    parser.add_argument('-m', '--mapping',
                        help='File to store function name to replacement type'
                             ' mapping, defaults to stdout')
    parser.add_argument('-e', '--enum',
                        help='File to store replacement type enum, defaults to'
                             ' stdout')
    parser.add_argument('-i', '--input',
                        help='''File containing a mapping from instrumented
                                functions to replacement types, to be used as
                                input''')

    args = parser.parse_args()

    if args.input:
        replacement_type_mapping = read_replacement_type_mapping(args.input)
    else:
        replacement_type_mapping = {}

    if args.mapping:
        mapping_file = open(args.mapping, 'w')
    else:
        mapping_file = sys.stdout

    if args.enum:
        enum_file = open(args.enum, 'w')
    else:
        enum_file = sys.stdout

    enum_file.write('// Generated by generate_replacement_type_enum.py\n')
    enum_file.write('\n')
    enum_file.write('#ifndef %s\n' % (os.path.basename(args.enum).rsplit('.', 1)[0].upper() + "_H"))
    enum_file.write('#define %s\n' % (os.path.basename(args.enum).rsplit('.', 1)[0].upper() + "_H"))
    enum_file.write('\n')
    enum_file.write('using namespace std;\n')
    enum_file.write('\n')

    enum_file.write('typedef enum {\n')
    enum_file.write('    _no_replacement_type,\n')
    for replacement_type in replacement_type_mapping.keys():
        enum_file.write('    %s,\n' % replacement_type)
    enum_file.write('} _replacement_type;\n')
    enum_file.write('\n')
    enum_file.write('#endif\n')

    mapping_file.write('// Generated by generate_replacement_type_enum.py\n')
    mapping_file.write('\n')
    mapping_file.write('#ifndef %s\n' % (os.path.basename(args.mapping).rsplit('.', 1)[0].upper() + "_H"))
    mapping_file.write('#define %s\n' % (os.path.basename(args.mapping).rsplit('.', 1)[0].upper() + "_H"))
    mapping_file.write('\n')
    mapping_file.write('#include "%s"\n'
                       % (os.path.basename(args.enum) if args.enum else "stdout"))
    mapping_file.write('\n')
    mapping_file.write('using namespace std;\n')
    mapping_file.write('\n')

    mapping_file.write('struct func_mapping_entry {\n')
    mapping_file.write('    const char *func_name;\n')
    mapping_file.write('    _replacement_type type;\n')
    mapping_file.write('};\n')
    mapping_file.write('\n')

    mapping_file.write('static struct func_mapping_entry func_mapping_table[]'
                      ' = {\n')
    for mapping_entry in replacement_type_mapping.items():
        replacement_type = mapping_entry[0]

        for func_name in mapping_entry[1]:
            mapping_file.write('    {"%s", %s},\n'
                               % (func_name, replacement_type))
    mapping_file.write('    {NULL, _no_replacement_type}\n')
    mapping_file.write('};\n')
    mapping_file.write('\n')
    mapping_file.write('#endif\n')

    try:
        enum_file.close()
    except IOError:
        pass

    try:
        mapping_file.close()
    except IOError:
        pass


if __name__ == '__main__':
    main()
